createdAt: "2018-05-03T02:24:58.537Z"
updatedAt: "2018-05-03T06:23:03.848Z"
type: "MARKDOWN_NOTE"
folder: "becbb124877573c964e3"
title: "1-java运行时数据区域"
content: '''
  ### 1-java运行时数据区域
  
  ---
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-ec67ec0def069590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  
  #### 程序计数器
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-8355a056966aa1c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  > **作用:**
  
  **程序计数器**是较小的内存空间，它可以当做是**当前线程所执行的字节码的行号指示器**。
  
  **字节码解释器**工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，**分支**，**循环**，**跳转**，**异常处理**，**线程恢复**等基础功能都需要依赖这个程序计数器来完成。
  
  > **程序计数器的线程隔离性**
  
  java 虚拟机的多线程都是通过**线程轮流切换**并分配处理器执行时间的方式来实现的，在任何一个确定的时间,一个处理器(对于多核处理器来说是一个内核)都会只执行一条线程中的指令。因此为了保证线程的执行，每一个线程都有一个独立的线程计数器，各个线程的程序计数器 相互独立，互不影响。
  
  
  > **说明:**
  
  1. 如果线程执行的时一个Java代码，这个计数器记录的是**正在执行的虚拟机字节码的指令地址**。
  2. 如果正在执行的时Native方法,这个计数器值则为空。
  3. 此内存区域是为一个在Java虚拟机中没有规定任何**OutOfmemoryError**情况的区域.
  
  #### java 虚拟机栈
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-93bf0a5d4b344d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  > **作用**:
  
  java 虚拟机栈描述的是java方法执行时候的内存模型。
  
  每一个栈帧用于**存储局部变量表**,**操作数栈**,**动态链接**,**方法出口**等信息。
  每一个方法从调用直至完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
  
  > **哪些局部变量可以存放到java 虚拟机栈中?**
  
  **局部变量表**存放了预编译期的可知**基本类型(boolean, byte, char, sort, short, int, float, long, double)**,**对象引用(可能是一个指向对象的指针,也可能是指向一个代表对象的句柄)**
  
  64位长度的基本类型(long, double)会占用两个局部变量空间，其余的数据类型只占用一个。
  
  > **说明**
  
  1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 **StackOverflowError**异常；
  2. 如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常;
  
  #### 本地方法栈
  
  
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-851d6fbb42586921.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  **本地方法栈**与虚拟机栈所发挥的作用是非常相似的，他们的区别不过是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机使用到的**Native方法服务**。
  
  #### java 堆
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-e06ff86e2dd287a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  对于绝大多数应用程序来说: **Java 堆是java虚拟机所管理的内存中最大的一块。**
  
  **Java 堆是被所有线程共享的一块内存区域，在虚拟机时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里面分配内存(随着JIT发展，所有对象都在堆上分配变得不再绝对)。**
  
  > **说明:**
  
  如果堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常。
  
  
  #### 方法区
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-1e3c9cf7507c227c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的**类信息**，**常量**，**静态变量**，即使编译器编译编译后的代码等数据。
  
  > **运行时常量池**
  
  运行时常量池是方法区的一部分， Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量中存放。
  
  #### 直接内存:
  
  > **什么是直接内存?**
  
  **直接内存**并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。
  
  在 JDK 1.4 中新加入了NIO类，引入了一种**基于通道与缓冲区的I/O方式**,他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中**DirectByteBuffer**对象作为这块内存的引用进行操作。
'''
tags: []
isStarred: false
isTrashed: false

createdAt: "2018-04-28T06:29:30.640Z"
updatedAt: "2018-04-28T10:46:59.133Z"
type: "MARKDOWN_NOTE"
folder: "7e52a01ed824a11f4a8d"
title: "19-选择排序"
content: '''
  ### 19-选择排序
  
  ---
  
  ### 1. 简单选择排序
  
  选择排序（Selection Sort）是一种简单直观的排序算法。
  
  > 它的工作原理如下:
  **首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。**
  以此类推，直到所有元素均排序完毕。
  
  选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。
  选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。
  
  #### 实例分析
  
  以数组 arr=[8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 为例，先直观看一下每一步的变化，后面再介绍细节
  
  第一次从数组 [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 中找到最小的数 0，放到数组的最前面（与第一个元素进行交换）
  
  ```
                                min                              ↓
  8   5   2   6   9   3   1   4   0   7
  ↑                               ↑
  └───────────────────────────────┘
  
  ```
  
  交换后：
  
  ```
  0   5   2   6   9   3   1   4   8   7
  ```
  
  在剩余的序列中 [5, 2, 6, 9, 3, 1, 4, 8, 7] 中找到最小的数 1，与该序列的第一个个元素进行位置交换：
  
  ```
                         min
                          ↓
  0   5   2   6   9   3   1   4   8   7
      ↑                   ↑
      └───────────────────┘
  ```
  
  交换后：
  
  ```
  0   1   2   6   9   3   5   4   8   7
  ```
  
  在剩余的序列中 [2, 6, 9, 3, 5, 4, 8, 7] 中找到最小的数 2，与该序列的第一个个元素进行位置交换（实际上不需要交换）：
  
  ```
         min
          ↓
  0   1   2   6   9   3   5   4   8   7
          ↑
  ```
  
  重复上述过程，直到最后一个元素就完成了排序。
  
  ```
                     min
                      ↓
  0   1   2   6   9   3   5   4   8   7
              ↑       ↑
              └───────┘
                             min
                              ↓
  0   1   2   3   9   6   5   4   8   7
                  ↑           ↑
                  └───────────┘
                         min
                          ↓
  0   1   2   3   4   6   5   9   8   7
                      ↑   ↑
                      └───┘
                         min
                          ↓
  0   1   2   3   4   5   6   9   8   7
                          ↑   
                                     min
                                      ↓
  0   1   2   3   4   5   6   9   8   7
                              ↑       ↑
                              └───────┘  
                                 min
                                  ↓
  0   1   2   3   4   5   6   7   8   9
                                  ↑      
                                     min
                                      ↓
  0   1   2   3   4   5   6   7   8   9
                                      ↑
  ```
  
  #### 代码分析:
  
  ```
  #include <iostream>
   using namespace std;
  
  void SelectSort(int *pData,int size)
  {
      for(int i = 0;i<size-1;++i)
      {
          int index = i;
          for(int j = i+1;j<size;++j)
          {
              if(pData[j]<pData[index])
                  index = j;
          }
          if(index != i)
          {
              int temp = pData[i];
              pData[i] = pData[index];
              pData[index] = temp;
          }
      }
  }
  
  int main()
  {
      int pData[10]={1,5,9,3,4,7,8,2,6,10};
      for(int i = 0;i<10;++i)
          cout<<pData[i]<<' ';
      cout<<endl;
      SelectSort(pData,10);
      for(int i = 0;i<10;++i)
          cout<<pData[i]<<' ';
          
      return 0;
  }
  ```
  
  ### 2. 堆排序
  
  **堆(二叉树)** 可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。
  如下图，是一个堆和数组的相互关系
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-03798953d31c290a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：
  
  - **i 的父节点下标**: $Parent(i)=floor(i/2)$ 
  - **i 的左子节点下标:** $Left(i) = 2i$         
  - **i 的右子节点下标:** $Right(i) = 2i + 1$
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-e89eb5aecf241a7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  
  > 二叉堆一般分为两种：最大堆和最小堆:
  
  **最大堆**:
  
  - 最大堆中的最大元素值出现在根结点（堆顶）
  - 堆中每个父节点的元素值都大于等于其孩子结点（如果存在）
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-3a8970134ddc4807.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  
  **最小堆:**
  
  - 最小堆中的最小元素值出现在根结点（堆顶）
  - 堆中每个父节点的元素值都小于等于其孩子结点（如果存在）
  
  ![image.png](https://upload-images.jianshu.io/upload_images/10402860-dd2e92c22a2b99af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
  ### 3.  堆排序原理:
  
  堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：
  
  最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
  创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆
  堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算
'''
tags: []
isStarred: false
isTrashed: false
